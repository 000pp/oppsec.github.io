
[{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/","section":"1337.coffee","summary":"","title":"1337.coffee","type":"page"},{"content":" What is Azure and Blob? # Azure, or Microsoft Azure, is a cloud computing platform maintained by Microsoft that offers a bunch of services used by many companies and individuals. Probably, the most famous solutions provided by Microsoft Azure are virtual machines, Azure Kubernetes Services (AKS), solutions for DevOps and DevSecOps, and of course, the giant integration with all other Microsoft services, for example, Active Directory, GitHub, Azure DevOps, Visual Studio, and GitHub Copilot.\nNow, what is Azure Blob Storage? Azure Blob Storage is a massively scalable and secure object storage solution for cloud-native workloads, archives, data lakes, HPC, and machine learning (I took this from the Microsoft Azure Blob Storage website). Basically, a lot of companies store their files like videos, documents, executables, logs, backup data, and others in this service and share these resources through their services like web apps, systems, etc.\nA Blob Storage is constructed of three types of resources, which are:\nStorage Account: A Storage Account is the unique namespace for your Azure data. So, if you store your data on Azure Storage, your data will be available at an address that uses this namespace as the reference for access. Example: https://oppsec.blob.core.windows.net.\nContainer: A container is where all the blobs get stored; they work similarly to a directory in a file system. A good thing is there is no limit to how many blobs can be stored in a container, of course, because the purpose is to provide large storage access. A container name can be between 3 and 63 characters long and doesn\u0026rsquo;t support special characters besides the dash character (-).\nBlob: A blob is a binary large object and a storage option for any type of data that you want to store in a binary format. (I took this from Microsoft again)\nAzure Blob Storage diagram that I stole from Microsoft documentation\nAzure Blob Storage is basically Microsoft\u0026rsquo;s version of Amazon S3 Bucket or Google Cloud Drive. The main purpose is to serve access to a large scale of files and provide more flexibility in the storing process.\nWhy should I know about this? # Well, we\u0026rsquo;re hackers, or pentesters\u0026hellip; so we should know about a bunch of things. Today, it is extremely easy to find websites that use Microsoft services/technologies like IIS, ASP.NET, and now, Azure services, like Azure Blob Storage. If we understand the environment that we are fighting in, we know how to find vulnerabilities and create a good report for the client. I have already done a lot of pentests on clients that use Azure Blob Storage and discovered interesting info and sensitive data about the web app, infrastructure, or environment I was attacking with this knowledge.\nNow that you understand the importance of knowing what Azure Blob Storage is, we can start talking about the good part: the vulnerabilities that we can find while dealing with this service.\nAnonymous Access # The main advantage of Azure Blobs compared to other Azure artifacts like Azure Files (SMB and REST), Azure Queues, and Azure Tables is that Azure Blobs allow anonymous public read access, as we can see in the image below: With anonymous access and the right request, we can enumerate all the blobs (files) inside the target Azure Blob Storage and find really good information. As we said before, the base URL for an Azure Blob Storage is STORAGE_ACCOUNT_NAME.blob.core.windows.net, so you need to first discover the Storage Account name. It can be easily discovered if the web app makes a direct request for the file it needs. For example: In the image above, before the first dot is the storage account name. If you can\u0026rsquo;t find the storage account this way, I recommend trying three things:\nGoogle Dorking Use the company\u0026rsquo;s name Bruteforce with a custom wordlist Try using FFUF with a custom wordlist that combines the company name and a generic storage name, like amazoncontent, amazonstorage, amazonfiles.\nIf you can find a valid Azure Blob Storage domain, you\u0026rsquo;re probably going to find a page similar to this: As we can see in the image above, the service is asking for the parameter \u0026ldquo;comp\u0026rdquo;. If we look at Microsoft\u0026rsquo;s documentation, it says we can enumerate container names using ?comp=list, but this never worked for me. In an ideal world, like the first image I showed you, the container name will be in the URL. Example: https://oppsec.blob.core.windows.net/static/js/jquery.js — static is the container name. Again, you can use FFUF to enumerate container names. As you can see, the container name is static, a common word.\nThe main problem here is Azure Blob Storage does not indicate if the container name is valid or not, i.e. static can be a valid container name and notnotnotvalid invalid but we will get the same response for both:\n\u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;ResourceNotFound\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt; The specified resource does not exist. RequestId:4f8c64bf-701e-0024-4099-3cb3d7000000 Time:2024-11-22T04:47:01.2790826Z \u0026lt;/Message\u0026gt; \u0026lt;/Error\u0026gt; Accessing blobs from a container # But Microsoft is not an evil company, and there is a way to identify if the container name is valid or not. We need to append ?restype=container\u0026amp;comp=list or just ?comp=list to the end of the URL, and blobs will be listed. With this in mind, we can go back to FFUF and enumerate valid container names through this command:\nffuf -c -w /opt/SecLists/Discovery/Web-Content/common.txt --fc 404 --mc all -u https://oppsec.blob.core.windows.net/FUZZ?comp=list ffuf -c -w /opt/SecLists/Discovery/Web-Content/common.txt --fc 404 --mc all -u https://oppsec.blob.core.windows.net/FUZZ?restype=container\u0026amp;comp=list Of course, you can use the tool of your choice, but I really like FFUF and have been using it for the last few years.\nNow you can list the blobs. You just need to access the URL indicated by the Name or Url values. For example, if I want to access the .less file from the image I used above, the URL would be something like this: https://oppsec.blob.core.windows.net/static/backend/REDACTED/css/REDACTED.less I used this file as an example, but you can find internal documents by searching for files that end with pdf, csv, xlsx, xls, docx, or low-hanging fruits with js, zip, sql files. Or just adapt the search based on the environment you\u0026rsquo;re exploring. If the web app is developed with PHP, you can search for php, inc, bkp.\nAnother problem is Azure Blob Storage is used to store a large scale of files. If you want to find files that end with pdf, you will need to use CTRL+F on your browser and filter one by one. If that wasn\u0026rsquo;t enough, you may come across errors like FeatureVersionMismatch and will need to specify the x-ms-version header with the vlaue 2020-04-08.\nI\u0026rsquo;m a person that likes to develop tools/scripts and bring more convenience to my life. So, I developed a tool to help with Azure Blob Storage. I called it Blobber, and it is developed with Python and ChatGPT\u0026rsquo;s help.\nBlobber # Blobber automates the process of adding ?restype=container\u0026amp;comp=list to the URL, checks for errors, tries to bypass them, and lets you view only the really important data and filter by extensions with more convenience. You can skip the filter by extensions flag too, but be careful because a lot of content will be printed (probably).\nI will not release Blobber for now because I want to do more tests and not release a tool that does not work as expected. However, it will eventually be available on my GitHub. The repo will be accessible through this URL https://github.com/oppsec/blobber.\nConclusion # Today we learned a bit more about the Azure Blob Storage service and how valuable it is to find one with anonymous access enabled. I really enjoyed reading about this through Microsoft\u0026rsquo;s documentation and developing this script (Blobber). In my opinion, this is the best way to learn something new and improve your skills. I hope all you guys liked this post and learned something new. I hope to see you again soon.\nReferences # https://learn.microsoft.com/en-us/azure/storage/blobs/ https://learn.microsoft.com/en-us/azure/storage/blobs/storage-blobs-overview https://learn.microsoft.com/en-us/rest/api/storageservices/blob-service-rest-api https://learn.microsoft.com/en-us/rest/api/storageservices/blob-service-concepts https://learn.microsoft.com/en-us/rest/api/storageservices/enumerating-blob-resources https://learn.microsoft.com/en-us/rest/api/storageservices/operations-on-containers ","date":"22 November 2024","externalUrl":null,"permalink":"/posts/attacking-azure-blob-storage-services/","section":"Posts","summary":"","title":"Attacking Azure Blob Storage Services","type":"posts"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/tags/azure/","section":"Tags","summary":"","title":"Azure","type":"tags"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/tags/microsoft/","section":"Tags","summary":"","title":"Microsoft","type":"tags"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/tags/pentest/","section":"Tags","summary":"","title":"Pentest","type":"tags"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 November 2024","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"24 October 2024","externalUrl":null,"permalink":"/tags/ldap/","section":"Tags","summary":"","title":"Ldap","type":"tags"},{"content":" O que é? # O Security Descriptor ou ntSecurityDescriptor, é um atributo de segurança do Windows que contém uma estrutura de dados representativa das permissões e propriedades daquele objeto em questão. Podemos interpretar o mesmo como uma ideia do escopo de permissões do X sobre Y. O ntSecurityDescriptor está presente desde as versões superiores do Windows Server 2000 e se manteve o mesmo desde então.\nO Security Descriptor é um representação compactada binária da segurança associada a objeto pertecente ao ambiente. Para comprovação disso, podemos tentar extrair o Security Descriptor de um usuário ou grupo por meio de uma query LDAP e vermos seu formato puro.\nÉ importante salientar que o ntSecurityDescriptor é utilizado por DACLs, SACLs, e ACL. Esses três atributos são responsáveis por representar as permissões desse objeto consumindo os dados do ntSecurityDescriptor. Essas permissões são de quem representa aquele objeto, quem pode acessar esse objeto e o que pode fazer com o mesmo, informações de auditoria do objeto e restrições sobre tal.\nACL: Access Control List é uma lista de proteções de seguranças que são aplicadas sobre um objeto. Deve-se entender que objetos podem ser um arquivo, processo, evento, ou tudo aquilo que também tiver um “Security Descriptor”; ACE: Access Control Entries são entrada de dados de ACLs (Access Control List). Uma ACE contém uma lista de permissões sobre um SID que irá identificar se tais permissões participam dos escopos: Allowed, Denied ou Audited; DACL: Discretionary Access Control List é o responsável por identificar os administradores ou objetos que tem permissões ou não sobre objetos protegidos. Caso um processo tente interagir com um objeto protegido, o sistema irá requisitar ao que ACE busque na DACL se aquele autor em questão tem as permissões necessárias; SACL: System Access Control List é uma lista que permite que adminstradores registrem tentativas de interação ou acesso a um objeto protegido. Cada ACE irá especificar as tentativas de acesso sobre aquele item e fará com que o sistema armazene essa tentativa no Security Event Log; De acordo com a Microsoft, o ntSecurityDescriptor utiliza de um sistema chamado Security Descriptor String Format. O Security Descriptor String Format é um formato ou sistema de texto responsável por armazenar ou transportar a informação do ntSecurityDescriptor. Isso é feito por duas funções chamadas ConvertSecurityDescriptorToStringSecurityDescriptorA e ConvertStringSecurityDescriptorToSecurityDescriptorA. Essas duas funções são utilizadas para o trabalho de conversão dos Security Descriptor.\nÉ possível transformar um “String Security Descriptor“ para um Security Descriptor Absoluto através de outra função que é chamada de MakeAbsoluteSD. Essas três funções iram retornar valores não nulos, caso todos os argumentos necessários forem repassados e serem válidos. Com o seu retorno, é possível extrair o formato do Security Descriptor.\nPara que as funções citadas acima possam descrever o formato do Security Descriptor, é utilizado a tecnologia SDDL (Security Descriptor Definition Language) que irá fazer essa tradução e permitir que as funções possam representar elas em texto. Aqui estão alguns exemplos de SDDL retirados do artigo da Microsoft:\nExemplos # Regra: Qualquer usuário poderá executar esse objeto se ele seguir as seguintes condições:\nO título dele ser PM A divisão ou setor dele for Financeiro ou Vendas d:(XA; ;FX;;;S-1-1-0; (@User.Title==\u0026#34;PM\u0026#34; \u0026amp;\u0026amp; (@User.Division==\u0026#34;Financeiro\u0026#34; || @User.Division ==\u0026#34;Vendas\u0026#34;))) Regra 2: Permite leitura do objeto se o usuário seguir as seguintes condições:\nSeu login ter sido feito a partir de um Smart Card É pertencente do grupo Backup Operator Está conectado em uma máquina com o BitLocker ativo D:(XA; ;FR;;;S-1-1-0; (Member_of {SID(Smartcard_SID), SID(BO)} \u0026amp;\u0026amp;@Device.Bitlocker)) Qual a sua importância? # Através do Security Descriptor, pode-se compreender qual o escopo de privilégios que aquele ativo terá sobre um item de seu interesse ou que haverá uma possível interação. Com isso em mente, a Microsoft desenvolveu esse atributo expressivo para que fosse alocado sobre os objetos do ambiente Active Directory e pudesse trabalhar as questões de controle de acesso. Atualmente, ele é utilizado por outras classes do ambiente Active Directory como:\nsamDomainBase: A classe base para a definição de domínios; securityPrincipal: Armazena informações de segura sobre um objeto; top: A classe de mais alto nível que é de onde todas as classes derivam; Hoje em dia, ferramentas como o BloodHound usufruem de ACEs e DACLs para identificar as permissões que um objeto tem sobre o outro, e assim, poder construir caminhos de exploração por meio de fragilidades do objeto X sobre o objeto Y.\nTrabalhando com o ntSecurityDescriptor # O ntSecurityDescriptor segue o seguinte formato O:BAG:BAD:S:, onde:\nO: Owner BAG e BAD serão utilizados para representar quem tem permissão de interação e quem não tem sobre aquele objeto. G é Granted e D é Deny. S representará o SACL. O atributo Owner irá indicar o proprietário por meio do SID do objeto, o BAG e o BAD são especificadores de controle de acesso e o SACL para poder armazenar as tentativas de interação com o objeto alvo. De uma maneira simples, se expandíssemos um Security Descriptor, esse seria o formato dele:\nComo podemos ver, o Owner e PrimaryGroup são as representações do proprietário daquele Security Descriptor. Com isso, podemos partir para a leitura da DACL que trará informações sobre a ACE do objeto protegido. Em um contexto de segurança ofensiva, o que diretamente nos importa seria o Access Mask dessa ACE.\nCom isso em mente, podemos capturar o Security Descriptor de objetos (usuários, grupos, etc) e lermos suas permissões e identificar possíveis fragilidades que atacantes podem utilizar para escalonar privilégios dentro de um ambiente Active Directory. Para isso, incrementei um módulo na minha ferramenta breads que irá buscar pelo valor do ntSecurityDescriptor de todos os objetos do ambiente através da query objectClass=(*) e checar as permissões se baseando no valor de ACE_MASK. Esses valores são hexadecimais que quando calculados, podem ser lidos como bits representantes de permissão. Essa é a tabela de permissões:\nEsse é o pedaço do código da minha ferramenta que irá realizar essa busca. O object_ntsd representa o acesso ao atributo ntSecurityDescriptor daquele objeto; já a variável sd está utilizando de uma classe do projeto Impacket para realizar a leitura dos bytes do Security Descriptor. Por fim, percorremos pelas chaves retornada da variável sd e acessamos seus valores respectivamente.\n# ... object_ntsd = attribute[\u0026#34;attributes\u0026#34;][\u0026#34;nTSecurityDescriptor\u0026#34;] sd = SR_SECURITY_DESCRIPTOR(data=object_ntsd) if sd[\u0026#34;Dacl\u0026#34;]: for ace in sd[\u0026#34;Dacl\u0026#34;].aces: ace_object = ace[\u0026#34;Ace\u0026#34;] # Ace_Object Vars: Mask, Sid ace_mask = ace_object[\u0026#34;Mask\u0026#34;][\u0026#34;Mask\u0026#34;] Após um tratamento sobre os hexadecimais retornados e quais são suas representações com base na documentação da Microsoft, podemos esperar um resultado como esse abaixo. Ressalto que foi utilizado uma conta participante do grupo de Domain Admins.\nConclusão # Assim, podemos compreender a relevância do ntSecurityDescriptor no Active Directory e como podemos utilizar dele para encontrar meios para realizar uma escalação de privilégios por meio de objetos presentes no ambiente. Como citado anteriormente, a ferramenta BloodHound faz um ótimo trabalhando usufruindo desse atributo para construir caminhos e gráficos com base nas informações coletadas do ambiente. Entende-se que tudo isso é principalmente útil para atacantes, todavia, esse tipo de processo também é de grande utilidade também para os times de operações defensivas, visto que poderão encontrar fragilidades na arquitetura monitorada.\nReferências # https://learn.microsoft.com/en-us/windows/win32/adschema/a-ntsecuritydescriptor https://learn.microsoft.com/en-us/windows/win32/adschema/c-samdomainbase https://learn.microsoft.com/en-us/windows/win32/adschema/c-top https://learn.microsoft.com/en-us/windows/win32/secauthz/security-descriptor-string-format?redirectedfrom=MSDN https://learn.microsoft.com/en-us/windows/win32/secgloss/a-gly https://learn.microsoft.com/en-us/windows/win32/secgloss/d-gly https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/4f4251cc-23b6-44b6-93ba-69688422cb06 https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/7d4dac05-9cef-4563-a058-f108abecce1d https://github.com/fortra/impacket/blob/f8899e65f16c50b871863528d419cfb701a5a3e3/impacket/ldap/ldaptypes.py https://learn.microsoft.com/en-us/windows/win32/api/iads/ne-iads-ads_rights_enum https://www.installsetupconfig.com/win32programming/accesscontrollistacl2_1.html ","date":"24 October 2024","externalUrl":null,"permalink":"/posts/security-descriptor/","section":"Posts","summary":"","title":"Security Descriptor, o que é e onde vive.","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/tag/","section":"Tags","summary":"","title":"Tag","type":"tags"}]